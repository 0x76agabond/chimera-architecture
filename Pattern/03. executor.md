# **Executor** – **Decorator × Composition** 
*If this chapter ends up confusing you, the shortcut is right* [*here*](https://github.com/0x76agabond/chimera-architecture/blob/main/Pattern/10.%20vision.md)

---
   
Many years ago, when I was a fresher, I worked for an ERP company.   
**We had a sacred rule that every function must have an error code in the format**

    {function_name}{error_code}
    error code is a 4-digit number like 0070, 0068, etc.

No one knew what those numbers meant, maybe some 
forbidden knowledge hidden between those numbers.

**We also had another rule: never forget the try - catch, and never forget Rule #1.**  
So of course we solved it by making a try–catch template file and copy-pasting it everywhere.

Sadly, everyone had their own version, so our logs looked like they came from five different projects ( **Who cares? We followed the rule!* ).  

And half the time we forgot to change {function_name}, so entire modules reported errors under the same name. ( **This is consistency!* ). 

**So I designed `Executor` for my past self, and maybe for that company too.**   
If they ever meet this pattern somewhere out in the wild, I hope it finally frees them from the ancient curse of copy-paste exception handling.

## **Ideas**

Old-school **decorators** were built through inheritance, using `protected` methods and overrides to bolt extra behavior onto a `class` without modifying it directly.  
They were the classic way to add **logging**, **retry**, or **audit** before composition became mainstream.

Modern systems use **decorators** to isolate cross-cutting concerns from `service` logic.  
This keeps each `service` small, clean, and easy to test without messy inheritance chains.

`Chimera` mixes both: the simplicity of old-school inheritance with modern **architecture-driven** composition.  
You get predictable behavior without turning everything into framework magic.

And of course, in modern systems everything must **favor composition over inheritance** and remain **DI-friendly**.  

## **Misuse the pattern**
`Chimera` bends the `decorator` pattern to make it more practical:

- Instead of inheritance, execution is wrapped through **composition** so the `service` stays clean and replaceable.  
- Error handling, timing, and logging are centralized inside an **Executor**, turning cross-cutting logic into a single reusable unit.  
- Everything remains **DI-friendly**, letting you swap, layer, or mock behaviors without touching business code.  
- This “misuse” converts a traditional pattern into a lightweight flow controller that amplifies structure while reducing boilerplate.

## **Examples**

#### Using decorator to handle cutting-edge concern
``` csharp
// Executor wraps any async action and adds cross-cutting behavior.
// No business logic is allowed here.
public sealed class Executor : ExecutorInterface
{
    private readonly LoggingInterface logger;

    // DI keeps Executor stateless and reusable.
    public Executor(LoggingInterface logger) => this.logger = logger;

    // ========= ASYNC EXECUTION WRAPPER =========
    // Handles: timing, exception capture, logging, and Result<T> shaping.
    // The child action remains pure business logic.
    public async Task<Result<T>> RunAsync<T>(
        LogLayer layer,
        string name,
        Func<CancellationToken, Task<T>> action,
        object? input = null,
        CancellationToken ct = default)
    {
        var sw = Stopwatch.StartNew();
        bool success = false;
        T? result = default;
        Exception? exception = null;

        try
        {
            // Execute the business logic safely.
            result = await action(ct).ConfigureAwait(false);
            success = true;
            return Result<T>.Ok(result!);
        }
        catch (OperationCanceledException oce)
        {
            // Standardized cancellation response.
            exception = oce;
            return Result<T>.Fail("operation_canceled");
        }
        catch (Exception ex)
        {
            // Never throw upward — convert to unified Result<T>.
            exception = ex;
            return Result<T>.Fail(ex.Message);
        }
        finally
        {
            sw.Stop();

            // Log only if the layer is enabled.
            if (SystemLog.IsLoggingEnabled(layer))
            {
                logger.Log(
                    layer.ToString(),      // log by layer instead of executor name
                    name,
                    success,
                    exception == null ? "" :
                        SafeString($"{exception.GetType().Name} - {exception.Message}"),
                    SafeString(input),
                    result,
                    sw.ElapsedMilliseconds
                );
            }
        }
    }
}
```

#### Using Executor in other layer
``` csharp
// Execute function using Executor pattern
    public virtual async Task<Result<int>> SaveDataAsync<T>(List<T> elems) where T : class
    {
        return await executor.RunAsync( LogLayer.Repository, nameof(SaveDataAsync), async () =>
        {
            var rs = await da.CreateMultiAsync(elems);
            Validation.vResultData(rs);
            return rs.Data;
        });
    }
```
## **Result**

I triggered a mock request to simulate a full API call.
The execution flows in the clean-arch order:

    Presentation → UseCases → Repository → Adapter → back up the stack.

Because each layer logs after finishing its part, the output appears upside down,
but you can still replay the entire workflow step-by-step from the logs.

``` json
// 15:31:39.2829989Z
{ "ts": "2025-11-25T15:31:39.2829989Z", "layer": "Adapter", "fn": "MockAdapter", "success": true, "error": null, "input": "mock-repository-inner", "data": null, "running_time": 0 }

// 15:31:39.3119673Z
{ "ts": "2025-11-25T15:31:39.3119673Z", "layer": "Repository", "fn": "MockRepository", "success": true, "error": null, "input": "mock-repository", "data": null, "running_time": 57 }

// 15:31:39.3129403Z
{ "ts": "2025-11-25T15:31:39.3129403Z", "layer": "UseCases", "fn": "MockService", "success": true, "error": null, "input": "mock-usecases", "data": null, "running_time": 59 }

// 15:31:39.3139965Z
{ "ts": "2025-11-25T15:31:39.3139965Z", "layer": "Presentation", "fn": "MockController", "success": true, "error": null, "input": "mock-presentation", "data": null, "running_time": 60 }

// 15:31:40.3309486Z
{ "ts": "2025-11-25T15:31:40.3309486Z", "layer": "Adapter", "fn": "MockAdapter", "success": true, "error": null, "input": "mock-repository-inner", "data": null, "running_time": 0 }

// 15:31:40.3322243Z
{ "ts": "2025-11-25T15:31:40.3322243Z", "layer": "Repository", "fn": "MockRepository", "success": true, "error": null, "input": "mock-repository", "data": null, "running_time": 1 }

```

## **Benefits**
- Reduce **boilerplate** — you never need to write `try/catch` again.
- Logs behave almost like **event sourcing**: they tell you what happened, where it failed, and how long each step suffered.
- Some might say it's hard to debug — it's not.  
  You only need **one breakpoint** to catch every exception in the entire system.
- The **`Executor` × `Loki` × `Grafana`** combo is **ridiculously powerful** for tracing and observability.
- This is the most **important pattern** in `Chimera` — the glue that connects every other `component` together.
- With this one, we should **abuse** it (every function that modifies the system’s state must be executed via `Executor`) — not just misuse it.

## **Notes**
- **Yes, I know. You and your AI best friend may worry about “logging only the message.”*  
  *But seriously — **just try it first**. The cosplay–event-sourcing style log is far stronger than the old-school full trace.*
  
- *Technically, you *can* include full stack traces, but calculate the trade-off carefully — your logs will grow absurdly fast.*

- *You gonna want to misuse my example, add a trace id and your log systems is ready for **distributed system***

## **Debates**

***Q. Yo wtf?? You kiddo really think we should bringing Solidity's modifiers into backend?***  
*A. Yes. It's good. It frees you from try–catch. Why don’t abuse it?*

***Q. So you wanna keep the performance overhead secret?***  
*A. Nah, their AI best friend will probably tell them.*  
   - *In a normal application, this performance trade-off is a good deal.*
   - *For high-performance systems, they can always go further, build a precompile-style plugin that injects the Executor into each function and removes the lambda entirely.*

***Q. But it's so complicated!***  
*A. It was 60 lines of code and it's right there.  
And you can add or remove anything you want.*  