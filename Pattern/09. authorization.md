# **Authorization** – **Reflection × DDD** 
*If this chapter ends up confusing you, the shortcut is right* [*here*](https://github.com/0x76agabond/chimera-architecture/blob/main/Pattern/10.%20vision.md)

---
Back when I was still a middle dev, I inherited an **oldschool MVC project**.  
`Authorization` used these weird magic codes like **HR-404**, **AD-911**, **XX-666**...  
Nobody knew what they meant. Not even the seniors.  
And the only guy who could mentor me quit one week after I joined.  

At that time I really **wished there was a system that could handle authorization automatically** for me.
But of course, life said no.

Maybe it was karma, I don't know.  
All I knew was I never want to touch that style of authorization again.

So this chapter is me fixing that childhood trauma.
The result turned out somehow clean and robust. 
I use it in my own systems, and you might find it helpful too.

## **The Idea**

`Chimera` uses a three-layer directory mapping to automate authorization.
Each class inherits its access rules directly from where it lives in the folder tree.

**1. `Zone` (Directory)**  
Defines who is allowed to enter the area
(e.g., Admin, User, Staff, Server).

**2. `Domain` (Directory)**
Defines the business scope the file belongs to
(e.g., Manufacturing, Dyeing, Inventory).

**3. `Action` (File / Class)**  
Defines the actual behavior or use case
(e.g., Report, Prepare, Approve).

By combining these three layers, `Chimera` can automatically infer permissions without attributes, config files, or duplicated rules.  
Just place the file in the correct folder, and the authorization logic resolves itself.

## **The Pattern**

Since `Chimera` has already built a healthy relationship with `.NET`, we’ll continue using it here.  
`.NET` has a convenient convention where **Namespace = Directory**, and we’re going to abuse this.

**Here’s how to make the authorization pattern work:**

1. **You don’t need full DDD-style directory organization everywhere.**  
Just place the structure where authentication is required.  
For me, that’s usually in the `Presentation` or `Adapter` layer.  
If your system is more complex, you can push it down to `UseCase` or `Core`.

2. **Your directory structure should follow:**  
`Zone` → `Domain` → `Class`.

3. **Each class must live inside the correct Zone it belongs to.**  
This is what gives it its access rule.

4. **No magic strings. No random constants.**  
Namespace checks should always use **nameof(namespace)**.

5. **You will want a tool to ensure the namespace actually reflects its real directory location.**  
**This prevents copy-pasta mismatches*.  *(I love pasta)*

6. **Reflection should always come with caching.**  
**No one wants authorization logic that scans assemblies on every request.*

7. **Estimate memory usage if you have a large number of authenticated classes.**  
**It’s usually cheap, but I put this note here just to be cautious.* 

8. **You need a central place to execute authorization logic.**  
Middleware works perfectly if you keep this in `Presentation` or `Adapter` like I do.  
If you want the paranoid version, you can abuse the [`Executor`](https://github.com/0x76agabond/chimera-architecture/blob/main/Pattern/3.%20executor.md) pattern to wrap every flow and double-check authorization.

9. **This setup should use local caching.**  
**Unless you enjoy watching your auth system summon ghosts from Redis.*

## **Example**

#### **Directory Structure**
``` text
/ZoneAdmin
    /Manufacturing
        ReportController.cs

/ZoneUser
    /Manufacturing
        ReportController.cs
```

#### **Controller Example**
**ZoneAdmin/Manufacturing/ReportController.cs**

``` csharp
namespace App.ZoneAdmin.Manufacturing;

public class ReportController
{
    public string Handle()
    {
        return "Admin Manufacturing Report";
    }
}
```
**ZoneUser/Manufacturing/ReportController.cs**
``` csharp
namespace App.ZoneUser.Manufacturing;

public class ReportController
{
    public string Handle()
    {
        return "User Manufacturing Report";
    }
}
```
#### Minimal Middleware Example
``` csharp
public class AuthMiddleware
{
    private readonly RequestDelegate _next;

    public AuthMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext ctx)
    {
        var route = ctx.GetEndpoint()?
            .Metadata.GetMetadata<ControllerActionDescriptor>();

        if (route == null)
        {
            // this is file request or portscan
            await _next(ctx);
            return;
        }

        string ns = route.ControllerTypeInfo.Namespace ?? "";
        string role = ctx.Request.Headers["role"].ToString();

        // zone names from typeof(_ZoneAdmin).Namespace
        string zoneAdmin = typeof(App.ZoneAdmin._ZoneAdmin).Namespace!;
        string zoneUser  = typeof(App.ZoneUser._ZoneUser).Namespace!;

        switch (ns)
        {
            case string z when z.StartsWith(zoneAdmin):
                if (role != "admin")
                {
                    ctx.Response.StatusCode = 403;
                    await ctx.Response.WriteAsync("forbidden");
                    return;
                }
                break;

            case string z when z.StartsWith(zoneUser):
                if (role != "user" && role != "admin")
                {
                    ctx.Response.StatusCode = 403;
                    await ctx.Response.WriteAsync("forbidden");
                    return;
                }
                break;

            default:
                // no zone => open access
                break;
        }

        await _next(ctx);
    }
}

```

## **Benefit**
- Highest level of codebase describes itself.
- No one needs to add auth attributes ever again.
- Infinite scaling powered by your file system.
- No identity conflict at least for your auth system.
- Zero-time onboarding just put the class where it belongs.  
**I mean the class only!*

## **Real Benefit**
As you can see from the example, the system can instantly tell what the request is trying to do.
It can spot a normal file call, a function call with auth, a harmless public function call, or some lonely portscan knocking on your door.

It’s gonna be epic if used as a gateway layer.  

Imagine letting Nginx redirect every request to this authorization entry point before anything else in the system is allowed to run.  
The gateway would instantly classify the request, validate the namespace rules, and take out anything invalid.     

**I wonder, what if you redirect invalid request to a ten-hours 8k SFW content?*  
**The poor portscan bot would probably reconsider its life choices*.  
**Please make sure to choose content that people actually enjoy watching*.  
****Holy shit, what am I saying? Sorry. Realistically you probably just want to delay or block the request completely.***

## **Debate**
***Q. Why don’t you just use strings?***  
*A. To make sure your `IDE` and `DI` will cry out loud if someone changes class name or namespace.*  

***Q. Why not use Redis, I can confidently say I can implement this really well with Redis***.  
*A. Local cache resets itself every time I restart the service, which happens on every deploy. Anyway, I wanna learn from you.*

***Q. Hey dude, your auth system will break in a real environment that needs sophisticated authorization.***  
*A. Hey dude, this is just Middleware logic, you can plug in any weird rule your system requires.*  
*I am only selling the idea of `DDD` boundaries and reflection-based discovery, not a full enterprise IAM solution.*  
*And for cases like temporary auth, the default block already supports handling that logic cleanly.*

***Q. Wtf is that redirect thing?***  
*A. I accidentally typed it out, my bad, sorry…*  

