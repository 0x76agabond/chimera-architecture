# **Hello World**
*If this chapter ends up confusing you, the shortcut is right* [*here*](https://github.com/0x76agabond/chimera-architecture/blob/main/Pattern/10.%20vision.md)

---
Every architecture needs a starting point.
This section **introduces the core rules that keep Chimera predictable, flexible, and still fully aligned with `Clean Architecture`**.  
**`Chimera` adds more tools, more flow, and more freedom**, but the boundaries should be respected.

### **Why Chimera Exists**
Modern architecture often demands more layers, more boundaries, and more rules.  
These things help with discipline, but they do not always help you grow technically.  
Sometimes they only make work heavier.  

`Chimera` tries to fix that.
Every rule and pattern has a purpose, whether it is reducing boilerplate, improving DX, or sharpening your instincts as a developer.

Throughout Chimera I use many stories about people and projects.  
**Some might be true, some might not, but the characters are all imaginary**.

Think of `Chimera` the same way you think of `Don Quixote`.  
A madman who read too many architecture articles until the world around him started to bend and shimmer like an illusion.

The poor guy finally stood up, yelling at the sky, and began his journey.  
But his giants were design patterns, not windmills 

Anyway...  
***Make Architecture Fun Again!***

### **Rules**
1. Must follow **Clean Architecture** dependency rule.  
2. `Adapter` must pair with a `Verifier` or `Repository`.  
3. `Adapter` exposes **everything** the underlying library/infra can do.  
4. `Verifier`/`Repository` stays **stateless** and validates all input before calling the adapter.  
5. `Flow` orchestrates the full use-case flow.  
6. `Service` provides use-case–specific logic.  
7. `Kit` handles real-world messy data.  
8. `Executor` is the **single decorator** for logging, timing, and exception capture.  

9. There are **3 levels of dependency injection**:  
   - Static dependencies via **DI container**.  
   - Runtime context injected via **Init()**.  
   - Runtime types injected via **inheritance or factory**.  

10. All layers use **composition first**, inheritance second, and marker interfaces to lock behavior contracts + enable DI wiring.  
11. **Template Method** defines shared boilerplate and allows subclasses to override specific steps.  
12. `EnsureInit()` blocks execution until all required context is ready.  

13. Each use-case expands **only as needed**:  
    - Simple flows → only `Service` (**pure Clean Architecture**).  
    - Need multiple step → add `Flow`.  
    - Heavy data handler → add `Kit` to isolate external chaos.  
    - Need to do CRUD → add `Repository`.  

14. No logic inside **Adapter**, no business inside **Repository**, no infra inside **Service**.    
15. Boundaries must **never leak**.   
Data crosses layers only via DTO/DO/VO.  
16. No global state, all state must live inside controlled runtime context.  
17. The system grows or shrinks with complexity, but **boundaries stay clean and stable**.

---