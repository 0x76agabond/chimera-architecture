# **3 Levels of Dependency Injection**

Ok, I'm gonna admit it — this `“3 levels of DI”` thing is not that special.  
It’s basically the life-cycle of an object, just written out.

Take a `Service` that controls a `WPF` form as an example.  
When it’s first created, its state is `Init`.  
After the form opens and all controls are loaded, its state becomes `Loaded`.  
When you're done working with the form, you probably want to save everything to the database before closing it.

**And then your random manager decides to change the report format every two days.**  
**You have 50 possible formats, no stable requirement, and zero clue what the next version will look like.**

**→ At this point your best bet is a mechanism that:**
- Auto-maps data.  
- Chooses behavior based on runtime input.  
- Reduces boilerplate.  
- And still looks somewhat elegant.

That’s the core idea behind the 3-level DI model.

## **The Pattern**
**Yes, no misuse this time, sad*

**Static DI**
- Dependencies are wired through the container at startup.
- Ideal for stable services, adapters, and cross-cuttininfrastructure.

**Context DI**
  - Runtime context is injected through an    explicit Init() call.
  - Works for objects requiring per-request   state (WebView2 sessions, scraping context, tokens).

**Type Manipulation**
  - Behavior is switched at runtime through   inheritance, factory selection, or    marker-based dispatch.
  - Useful when the system needs dynamic  behavior without breaking Clean  Architecture boundaries.

## **Rule**

- **Abuse** `Static DI`, if something **can** be injected with it, it.
- When dealing with objects only available at runtime (like the cursed WPF form)  
  and you must pass context → use `Context DI`.
- With `Context DI`, you **must ensure the context is injected** before calling any function that depends on it.
- When you need to change behavior at runtime, or you’re working with objects that keep changing,  
  use `Type Manipulation`.
- `Type Manipulation` is a **risky pattern**, so only use it when dealing with legacy systems   or when you must survive a random manager’s requirements.

## **Example**

### **1. Static DI**
- Standard dependency injection

``` csharp
public class Service {
    private readonly ILogger logger;
    
    public Service(ILogger logger) {
        this.logger = logger;
    }
}
```
### **2. Context DI**
``` csharp
public class RuntimeService
{
    private readonly IExecutor executor;
    private IRuntimeObject runtimeObject;

    // Lock for safe one-time initialization
    private readonly object _initLock = new();
    private bool isInit = false;

    public RuntimeService(IExecutor executor)
    {
        this.executor = executor;
    }

    // Runtime DI: inject context object once
    public bool Init(IRuntimeObject obj)
    {
        if (isInit) return true;

        lock (_initLock)
        {
            if (!isInit)
            {
                runtimeObject = obj;
                isInit = true;
            }
        }

        return isInit;
    }

    // Guard: ensure Init() was called
    private void EnsureInit()
    {
        if (!isInit)
            throw new InvalidOperationException("RuntimeService must be initialized before use.");
    }

    public async Task<Result<T>> DoThing<T>()
    {
        return await executor.RunAsync<T>(
            LogLayer.Service,
            nameof(DoThing),
            async () =>
            {
                // Required for any runtime-dependent logic
                EnsureInit();

                T output = await runtimeObject.DoThingAsync<T>();
                return output;
            });
    }
}
```
### **3. Type Manipulation**
``` csharp

// Base Report table
public abstract class Report
{
    public string ReportInformation { get; set; }
    // Imagine your real report columns 
    // probably more than 20 col
}

public class Report1 : Report
{
    // another format have Author
    public string Author { get; set; }
}

public class Report2 : Report
{
    // another format have Assistant
    public string Assistant { get; set; }
}


// Repository can save multiple type of Report
public interface IReportRepository
{
    Task SaveAsync<T>(T report) where T : Report;
}

// Service
public async Task SaveReport<T>(T report) where T : Report
{
    await executor.RunAsync(
        LogLayer.Service,
        $"{nameof(SaveReport)}-{typeof(T).Name}",
        async () => await repo.SaveAsync(report)
    );
}

// Now you can save report like this
ReportService svc = new(repo, executor);

await svc.SaveDataAsync( 
  new Report1 { 
    ReportInformation = "info", 
    Author = "me" 
}); 

await svc.SaveDataAsync( 
  new Report2 { 
  ReportInformation = "info", 
  Assistant = "my unpain AI assistant" 
});   

```

### **4. Type Manipulation Factory**
**Model**

``` csharp
// Base report

public abstract class Report
{
    [Key]  
    public guid id { get; set; }
    public string ReportInformation { get; set; }
}

[Table("report1")]
// Single child format
public class Report1 : Report
{
    public string Author { get; set; }
    public string Assistant { get; set; }
}

```
**ReportService**

``` csharp
public class ReportService : IReportService
{
    public Report Fill(Func<Report> factory)
    {
        // create correct child at runtime
        var rp = factory();

        // fill shared content
        rp.ReportInformation = "This is a filled report";

        // you probably fill more than 20 columns here

        return rp;
    }
}
```
**ReportRepository**
``` csharp
public class Report1Repository : IReport1Repository
{
    // one comment per function
    public Task SaveAsync(Report1 rp)
    {                
        // table report1 save     
        return Task.CompletedTask;   
    }
}

```
**ReportFlow**
``` csharp
// assume DI injected correctly
IReportService fill;
IReport1Repository repo;

public async Task RunWorkFlow()
{
    // fill child via base type
    Report rp = fill.Fill(() => new Report1());

    // fill data that only report1 have
    // you should put this on Service layer on production.
    rp.Author = "me";
    rp.Assistant = "my poor unpaid AI assistant";

    // cast back, safe because factory decides
    await repo.SaveAsync((Report1)rp);
}
```
## **Note**

- **Yes, I know you’re disappointed, there’s no magic here.* *The `3 levels of DI` & `manipulation thing` probably made you expect reflection, process hooking, remote threading etc...*

- *Since those features were out of scope,
so I’ll just give you some ideas to mess around with.*
***You shouldn’t use these things in production code, it's for security or experiments only except reflection.***

- *`Reflection` **should always be paired with cache**.*

- *`Reflection` does have a very special role in `Chimera`
but that’s for another chapter.*

## **Note**
**This is a high risk high reward pattern, **don't abuse it blindly***  
**Some patterns in Chimera can create epic combo if combined with each other, this one is one of them*

## **Debate**
***Q. Your Type Manipulation is complicated AF, and it's gonna be abused or misused.***  
*A. Ok, I never said it's easy. I just said it's not a “grey” thing*  
*I don't even dare to use the word misuse/abuse in that section*.

***Q. The RunWorkFlow in Type Manipulation Factory looks like a god function in real life.***  
*A. Hi, you can separate multiple base Reports based on their columns.*  
*Enterprise reports usually share similar column groups depending on their office.*
