# **Meta Programing** - **Reflection x Caching**
*If this chapter ends up confusing you, the shortcut is right* [*here*](https://github.com/0x76agabond/chimera-architecture/blob/main/Pattern/10.%20vision.md)

---

I once met a team struggling with their old-school system.
They tried to scale by stacking modern tools `Docker`, `K8s`, `ELK`...
but every new layer only made the server heavier.

A single request triggered multiple layers of **“best practices”**
that felt just like the old SQL days - **One UPDATE summoning an army of triggers.**

And to solve that…
they added `Redis` to reduce the request rate hitting their server.  
**Add a RAM-killer to solve a RAM problem...*  
**It might make sense if they added a new server with Redis to off-load memory. But sadly, they didn’t.*

I felt bad for those modern stacks. It looked like a princess in feudal times being forced to marry a sickly king,
then having to watch him suffer more and more each day.

*Sometimes I wonder **what that poor system ever did to them**, why they keep throwing stones at it even when it’s already down.*  
*I never learned how things ended, but I still wish them all the best.*  
***May they live forever, to maintain the monster they have summoned.***

## **Caching**
When people hear **“caching”**, they often think of `Redis` immediately as if cache is `Redis` and everything else doesn’t count.  
But the **truth is way simpler**.

**Caching** just means **storing data in RAM** so you can grab it quickly when needed.  
A plain **dictionary / JSON object with a TTL** is already a cache.  
You can **abuse any robust local cache library** you want, it all works.

**This is how the caching ladder looks.**
```text
Local Cache    (single server, in-memory)
   ↓
Regional Cache (shared across multiple servers)
   ↓
Global Cache   (multi-region, worldwide)
```
So to keep things **within `Chimera’s` scope**, throughout this  spec I’ll use the word **“cache”** to mean a simple dictionary.  
You can replace with any caching solution you prefer.  

(**You may go fancy and add five Redis layers. It's gonna be an epic stress test for your server*).

## **Reflection**
In `Chimera`, we **use Reflection for the cases that the architecture cannot solve through normal implementation**.  
I mentioned about it in other chapters — so here are the actual rules:
1. **We only use **reflection's read feature****  
    **Write feature is like Ars Goetia, it's scary!*
2. **Reflection must **go with cache****.
3. **Reflection can **only use** to implement meta feature**.  
    *if your presentation layer uses reflection, you're gonna want to refactor.*
4. **Don't abuse or misuse reflection**  
    **It hurts me when I type this but I must, poor me*

## **Example**
This example assumes we're **abusing `Dapper.Contrib`**, so we use its `Table` and `Key` attributes.
If you don't use `Contrib`, feel free to define your own attribute set, **make it epic**!


**Reflection Cache**
``` csharp
public sealed class ReflectionCache
{
    public static readonly ReflectionCache Instance = new();

    private readonly ConcurrentDictionary<Type, Dictionary<string, bool>> cache
        = new();

    private ReflectionCache() { }

    public Dictionary<string, bool> GetOrAdd(Type type)
    {
        return cache.GetOrAdd(type, Build);
    }

    private Dictionary<string, bool> Build(Type type)
    {
        return type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .ToDictionary(
                p => p.Name,
                p => p.IsDefined(typeof(KeyAttribute), inherit: true)
            );
    }
}

```
**Load Cached Column Metadata**
``` csharp
public Dictionary<string, bool> LoadColumns(object entity)
{
    var type = entity.GetType();
    return ReflectionCache.Instance.GetOrAdd(type);
}
```
**Use Reflection**
``` csharp
public bool UseReflection()
{
    var entity = new DataObject();

    // Load cached metadata (Reflection + Cache)
    var columns = LoadColumns(entity);

    // Read table attribute
    var type = entity.GetType();
    var tableAttr = type.GetCustomAttribute<TableAttribute>(inherit: true);
    var tableName = tableAttr?.Name;

    // Demo output
    foreach (var col in columns)
        Console.WriteLine($"{col.Key}: (isKey = {col.Value})");

    return true;
}
```
## **Benefit**

- Reflection lets you **go beyond the limits** of normal programming.

- You can use it to **enforce architecture rules at runtime**, **create meta-logic**, and **add constraints the language normally cannot express**.

- Reflection can also be used to **turn runtime errors into build-time failures** by generating checks or scripts that validate your structure before the system runs.

- ***This gives you a solid foundation to use `Context Injection`, `Type Manipulation`, and `Dynamic Query` safely.***

## **Debate**

***Q. Ars Goetia wtf??***  
*A. It’s part of the Lesser Key of Solomon, a book for summoning demons.*  
*There is a demon named “Your Junior Overwrites the Entire Project”. It’s terrifying.*

***Q. Why don’t you abuse the write-side of Reflection?***  
*A. Because it can bypass Chimera, I absolutely hate that!*

***Q. So what happened to the team in your story?***.  
*A. They should read this chapter and the [`Adapter`](https://github.com/0x76agabond/chimera-architecture/blob/main/Pattern/7.%20adapter.md) chapter then refactor*.  
*If they don't change their mindset, only God can help them*.

***Q. So you mean the modern stack is bad?***  
*A. No. The modern stack is great, but only when you understand what you're doing.*

