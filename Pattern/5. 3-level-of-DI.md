# **3 Levels of Dependency Injection**

Ok, I'm gonna admit it — this `“3 levels of DI”` thing is not that special.  
It’s basically the life-cycle of an object, just written out.

Take a `Service` that controls a `WPF` form as an example.  
When it’s first created, its state is `Init`.  
After the form opens and all controls are loaded, its state becomes `Loaded`.  
When you're done working with the form, you probably want to save everything to the database before closing it.

**And then your random manager decides to change the report format every two days.**  
**You have 50 possible formats, no stable requirement, and zero clue what the next version will look like.**

**→ At this point your best bet is a mechanism that:**
- Auto-maps data.  
- Chooses behavior based on runtime input.  
- Reduces boilerplate.  
- And still looks somewhat elegant.

That’s the core idea behind the 3-level DI model.

## **The Pattern**
**Yes, no misuse this time, sad*

- **Static DI**

    - Dependencies are wired through the container at startup.

    - Ideal for stable services, adapters, and cross-cutting infrastructure.

- **Context DI**

    - Runtime context is injected through an    explicit Init() call.

    - Works for objects requiring per-request   state (WebView2 sessions, scraping    context, tokens).

- **Type Manipulation**

    - Behavior is switched at runtime through   inheritance, factory selection, or    marker-based dispatch.

    - Useful when the system needs dynamic  behavior without breaking Clean  Architecture boundaries.

## **Rule**

- If something **can** be injected via `static DI` → use `Static DI`.
- When dealing with objects only available at runtime (like the cursed WPF form)  
  and you must pass context → use `Context DI`.
- With `Context DI`, you **must ensure the context is injected** before calling any function that depends on it.
- When you need to change behavior at runtime, or you’re working with objects that keep changing,  
  use `Type Manipulation`.
- `Type Manipulation` is a **risky pattern**, so only use it when dealing with legacy systems  
  or when you must survive a random manager’s requirements.

## **Note**
- **Yes, I know you’re disappointed, there’s no magic here.*
*The `3 levels of DI` & `manipulation thing` probably made you expect reflection, process hooking, remote threading etc...*

- Since those features were out of scope,
so I’ll just give you some ideas to mess around with.

- You shouldn’t use these things in production code, it's for security or experiments only except reflection.

- `Reflection` **should always be paired with cache**.

- `Reflection` does have a very special role in my architecture…
but that’s for another chapter.

