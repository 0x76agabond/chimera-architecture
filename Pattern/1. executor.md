# **Decorator × Composition**

Old-school **decorators** were built through inheritance, using `protected` methods and overrides to bolt extra behavior onto a `class` without modifying it directly.  
They were the classic way to add **logging**, **retry**, or **audit** before composition became mainstream.

Modern systems use **decorators** to isolate cross-cutting concerns from `service` logic.  
This keeps each `service` small, clean, and easy to test without messy inheritance chains.

`Chimera` mixes both: the simplicity of old-school inheritance with modern **architecture-driven** composition.  
You get predictable behavior without turning everything into framework magic.

And of course, in modern systems everything must **favor composition over inheritance** and remain **DI-friendly**.  

## **Misuse the pattern**
`Chimera` bends the `decorator` pattern to make it more practical:

- Instead of inheritance, execution is wrapped through **composition** so the `service` stays clean and replaceable.  
- Error handling, timing, and logging are centralized inside an **Executor**, turning cross-cutting logic into a single reusable unit.  
- Everything remains **DI-friendly**, letting you swap, layer, or mock behaviors without touching business code.  
- This “misuse” converts a traditional pattern into a lightweight flow controller that amplifies structure while reducing boilerplate.

## **Example**

#### Using decorator to handle cutting-edge concern
``` csharp
// Executor wraps any async action and adds cross-cutting behavior.
// No business logic is allowed here.
public sealed class Executor : ExecutorInterface
{
    private readonly LoggingInterface logger;

    // DI keeps Executor stateless and reusable.
    public Executor(LoggingInterface logger) => this.logger = logger;

    // ========= ASYNC EXECUTION WRAPPER =========
    // Handles: timing, exception capture, logging, and Result<T> shaping.
    // The child action remains pure business logic.
    public async Task<Result<T>> RunAsync<T>(
        LogLayer layer,
        string name,
        Func<CancellationToken, Task<T>> action,
        object? input = null,
        CancellationToken ct = default)
    {
        var sw = Stopwatch.StartNew();
        bool success = false;
        T? result = default;
        Exception? exception = null;

        try
        {
            // Execute the business logic safely.
            result = await action(ct).ConfigureAwait(false);
            success = true;
            return Result<T>.Ok(result!);
        }
        catch (OperationCanceledException oce)
        {
            // Standardized cancellation response.
            exception = oce;
            return Result<T>.Fail("operation_canceled");
        }
        catch (Exception ex)
        {
            // Never throw upward — convert to unified Result<T>.
            exception = ex;
            return Result<T>.Fail(ex.Message);
        }
        finally
        {
            sw.Stop();

            // Log only if the layer is enabled.
            if (SystemLog.IsLoggingEnabled(layer))
            {
                logger.Log(
                    layer.ToString(),      // log by layer instead of executor name
                    name,
                    success,
                    exception == null ? "" :
                        SafeString($"{exception.GetType().Name} - {exception.Message}"),
                    SafeString(input),
                    result,
                    sw.ElapsedMilliseconds
                );
            }
        }
    }
}
```

#### Using Executor in other layer
``` csharp
// Execute function using Executor pattern
    public virtual async Task<Result<int>> SaveDataAsync<T>(List<T> elems) where T : class
    {
        return await executor.RunAsync( LogLayer.Repository, nameof(SaveDataAsync), async () =>
        {
            var rs = await da.CreateMultiAsync(elems);
            Validation.vResultData(rs);
            return rs.Data;
        });
    }
```

## **Benefit**
- Reduce **boilerplate** — you never need to write `try/catch` again.
- Logs behave almost like **event sourcing**: they tell you what happened, where it failed, and how long each step suffered.
- Some might say it's hard to debug — it's not.  
  You only need **one breakpoint** to catch every exception in the entire system.
- This is the most **important pattern** in `Chimera` — the glue that connects every other `component` together.
- With this one, we should **abuse** it (all function must be executed via `Executor`) — not just misuse it.

## **Note**
**Yes, I know, you and your AI bestfriend may worry about “logging only the message.”
But just try it.
The cosplay event-sourcing style log is far stronger than old-school full trace logging (which only makes your logs look terrible).*




