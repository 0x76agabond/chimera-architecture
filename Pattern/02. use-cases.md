# **Use Cases** – **Flow × Service × Kit**
*If this chapter ends up confusing you, the shortcut is right* [*here*](https://github.com/0x76agabond/chimera-architecture/blob/main/Pattern/10.%20vision.md)

---

When I first learned `Clean Architecture`, the most confusing thing was the `Use Case`.  
There are some diagrams with concentric circles telling me it should “**do only one thing**.”

**Then I finally met it:**

- The `Use Case` that does exactly one job.  
- The `Use Case` that calls one other function.  
- The `Use Case` that calls five other functions.  
- The `Use Case` that simply forwards the call to a `Repository`.  
- …and so on.

**At some point I just asked myself:**

*“What did this `Use Case` do in its past life?*  
*Why does it have to suffer this much?*  
*…is this karma?”*

**So to save it from endless suffering,  `Chimera` separates it into three parts:**

- `Service` → pure unit of work  
- `Flow` (Orchestrator) → coordinates multiple steps  
- `Kit` → preprocesses cursed real-world data before anything else runs  

A `Use Case` can be any combination of these three depending on complexity.  
And this time, each one finally does **exactly one thing**.

## **The Triangle of Use Case**

### **1. `Service`**
The pure unit of business — focused, atomic, and honest about what it does.  
No orchestration, no data processing, just one clean unit of business per call.

### **2. `Flow`**
The conductor that strings multiple steps together without doing the steps itself.  
It defines the order, not the logic — a lightweight orchestrator.

### **3. `Kit`**
You already know this layer exists for **data preparation**, so let me give you real-world examples.
- Long ago I fought an `enterprise API` from a `big company` that returned four completely different response formats.  
  One of them was **HTML**.  
  *(Yes, I’m not mad, an API returning HTML.)*

- Another example: blockchain data.  
  Have you ever handled off-chain call/transaction results?  
  You receive an **array with no header**, no schema, no structure — nothing.  
  *(Even worse for systems that off-load byte parsing to off-chain components.)*

**After all, `Kit` is one of the most important concepts in Chimera, just like  the preprocessing stage in an AI pipeline**.

## **Rule**
**1. Code allowed to repeat for clarity (Copy, Repeat yourself "CRY"** if it makes sense)   
**You should keep your function in a way it can explain itself*.   
**A good example is when three Services all call the same Kit, keep it that way. Don’t create a helper just to wrap the Kit call*.   

**2. You can pass input direcly from `Presentation` to `Service` after verify, then let `Kit` handle it.**

**3. Each `Service` is allowed to call a maximum of one `Service` and one `Repository`. If it needs more, move logic to a `Flow`.**  
**One at home, one at office <3, work-life balance*

**4. Don't wrap a `Repository` with another `Repository`, use a `Flow` instead.**  
**This is as weird as wearing a nice T-shirt and still throwing an overcoat on a sunny day. It smells bad (I'm not talking about the code)*

## **Benefit**
- **Clear mental model**.
- Have room for **real world messy data**.
- Each type of file now **have similar stucture** which is more friendly with AI. 
- It's funny that my poor unpain AI assitant can **generate `Flow` from `Service Interface` and `Kit Interface`** (which made by the poor Architect guy) and `workflow PDF` (made by poor BA guy). I not even code yet! Poor me. 
- Since this part make your code base become **scalable based on complexity**, you definitely want to **abuse** it.

