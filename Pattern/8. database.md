# Database – Adapter × Dynamic Query × Repository

Let me guess, this is probably the most provocative pattern in `Chimera`.  
Because the moment you say `Dynamic Query`, every body hears.    

    Hi, I’m Bobby. Please hack me!

But since **our core mission is to reduce boilerplate and stay flexible**, ``Dynamic Query`` is necessary.

**You may ask me, why not `Entity Framework`?**  
→ *Because it sucks when being misused.*   
**You may also ask, why don't use dapper?**  
→  *Not just use, I abuse it*.

So at this point we gonna move on with these dangerous assumptions: 
1. **In modern technology any "robust" database you can find have at least one good database connector and one query builder.** 
    - **This sentence can be wrong*
2. **We chose the most light one (which give us more power and performance) and heavily abuse it**. 
    - **If (1) is wrong, this part becomes pointless.*
3. **`Infra` talks to the `library`, `library` talks to the `Adapter`, `Repository` performs validation to ensure everyone survives.** 
    - **If (1) is wrong, this also becomes pointless*

****Those assumptions aren’t even that dangerous, if your favorite database doesn’t have a good library,
you probably want to find an alternative!***

## **Note**
I want to write a full guide for multiple types of databases, but that would take more effort than the entire `Chimera Architecture` itself, so I’ll save that for later.

Within `Chimera`, I will **focus only on `SQL` and `Dapper`**.
Since most **applications handle databases in roughly the same way**, you might still find this spec helpful. ( **I guess.* )

## **Adapter × Dynamic Query**

Most heavy Dapper projects skip the adapter layer entirely.  
You often see a giant repository with hand-written CRUD SQL, full strings, tons of boilerplate, and a dev silently crying with IDE auto-complete (****me***).

**But the truth is:**
you don’t need that much SQL for 90% of business use cases.

What you really need is:

- Four simple CRUD functions (single-row operations)
- One bulk-insert function
- One `select-where` that returns multiple rows
- One raw-query entry point for stored procedures

This is enough to build almost every common workflow without drowning in SQL strings.

By placing **Dynamic Query** inside an **Adapter** and validating everything in the **Repository**,  
we keep the flexibility of Dapper while reducing boilerplate and controlling the trade-off.


## **Query deep dive**  
A dinamic query basically look like this 

``` SQL
Action (CRUD) + [columns] + From [table] + WHERE [columns] + ORDER / PAGING / LIMIT
```
which converted to C# look like 
``` csharp
// this is a bad example!
string input_action = ";drop database; select ";
string input_columns = ";drop again; a, b, c ";
string input_table = ";drop again; table_name ";
string input_where = $";drop again; a = {1} ";

string SQL = $"{input_action} {input_columns} FROM {input_table} WHERE {input_where} ORDER BY 1;";

// execute (SQL)
```
**This approach is:**  
- Quick!
- Straightforward!
- **And drops your database four times without returning anything.**

**The source of all evil is that, the normal `Dynamic SQL` let user input their query with `string`.**  

## **Chimera approach**
- **Each query has both static and dynamic components** depending on its nature.

- The `Adapter` defines all static parts of the query.  
**Base skeletons, column blocks, and structural templates...*

- `The Adapter` **must** use reflection and caching to handle table columns.

- `The Repository` enforce validation before pass to Database Adapter.

- `ValueObject` / `DataObject` define which columns **belong to the first block** (SELECT / UPDATE block).

- If a new feature is required, **the Repository creates only that feature**, no need to build a full SQL suite upfront.

- `Raw queries` are **allowed only for predefined stored procedures**, and **those procedures must also use parameterized queries**, especially when they contain dynamic SQL internally.

- Anything that goes into the WHERE block **must** use parameters.

- If your system doesn’t need complicated queries, you may abuse Dapper.Contrib for convenience.  
*But don’t expect it to solve real dynamic problems.*

- **At this point, since the Adapter only receives pre-defined objects from upper layers, there should be no attack vector for SQL injection.** But if you still worry, Dapper does have a library you should absolutely abuse: [InterpolatedSql](https://github.com/Drizin/InterpolatedSql).

- And if you don’t even trust your own team, build a table-name router with a hard whitelist.  
**In that case… you might be poorer than me. Poor you.*

## **Note**
- **After all, we can finally let Bobby rest. `Dynamic Query` isn’t that scary as long as we implement it correctly.*

- *I think you already sense this, but if you combine this `Database Layer` with [`Type Manipulation`](https://github.com/0x76agabond/chimera-architecture/blob/main/Pattern/5.%203-level-of-DI.md), [`Template Method`](https://github.com/0x76agabond/chimera-architecture/blob/main/Pattern/4.%20template.md), and the [`Kit Layer`](https://github.com/0x76agabond/chimera-architecture/blob/main/Pattern/2.%20use-cases.md), the result is a system where **changing table columns only requires updating the Kit and the Data Model** (likely 2 rows in my case).* 

- **This seems silly, but if you work in a position that needs to design data schemas, it's really helpful, especially for those poor guy who gets forced into schema design (**me**).*

- **If you don’t use `Dapper`, you can still **get a similar effect with most base connectors (parameterization is a must) combined with** `Reflection` and `Caching`.*

## **Debate**
***Q. What's your job actually?***  
*A. I'm a wandering architect*.

***Q. What does it ever mean?***  
*A. I go around and build houses*.

***Q. Reflection add overhead!***  
*A. Only for the first guy who touches it (the poor CI runner)*.
*Write a warm-up script or a small module that loads all entities after all dependencies have been injected*.


***Q. Who is Bobby ?***   
*A. I don't know but sorry Bobby*.