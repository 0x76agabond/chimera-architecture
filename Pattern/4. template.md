# **Template Method × Composition × Marker Interface**

This pattern is used across the Chimera Architecture to keep each layer predictable, easy to extend, and free from boilerplate.  
It combines three simple ideas:

- **Template Method** → shared flow, overridable details  
- **Composition** → behavior is injected, not inherited  
- **Marker Interface** → type-safe contracts without extra logic  ( **`DI container` forced me to use it* )

---
## **Misuse the Pattern**

#### **Template Method**
- The Template Method is intentionally inverted: the **base class** contains the shared logic used by ~80% of subclasses, while **child classes orchestrate the final behavior**.  
- It may include small logic steps (e.g., check → action → after-check), but it **must never manage long business flows**.

#### **Composition**
- Composition injects behavior dynamically, ensuring the template stays lightweight and flexible.  
- Any behavior that affects <20% of use-cases should be added through **pure composition**, not the template.

#### **Marker Interface**
- A marker interface is normally empty, but in Chimera it **inherits the base interface** to enforce type contracts.  
- It may optionally expose **extra functions** if a specific domain needs extension without breaking the template.
---

## **Rule**

- Template Method defines only the **shared workflow skeleton** — never the business rules.
- Template Methods are **append-only**: extend the flow, do not rewrite existing steps.
- If a change affects **30%+** of child classes → create a new template instead of mutating the old one.
- If a behavior applies to **<20%** of cases → prefer pure Composition × Interface instead of inheritance.
- Child classes may override steps, but must not turn the Template Method into a long-form orchestrator.

---

## **Real Rule**

1. **Keep functions clean**  
   Each step does exactly one thing. Add new steps when needed; avoid modifying existing logic.

2. **The percentages decision**  
   Template Method handles the 80% common workflow; use overrides or composition for the remaining 20%.  
   Treat the percentages as an anchor, not a strict rule — always ask: **“Is this worth a new template?”**

3. **Flexible skeleton**  
   The template defines a stable workflow outline; behavior is extended through composition or overrides, not long-form orchestration.

---

## **Example**

**Abstract Template: shared workflow**

```csharp
public abstract class ApplicationRepository : ApplicationRepositoryInterface
{
    protected readonly ExecutorInterface executor;
    protected readonly DatabaseAdapterInterface da;

    public ApplicationRepository(ExecutorInterface executor, DatabaseAdapterInterface da)
    {
        this.executor = executor;
        this.da = da;
    }

    // Template Method: common workflow for all repositories
    public virtual async Task<Result<int>> SaveDataAsync<T>(List<T> elems) where T : class
    {
        return await executor.RunAsync(
            LogLayer.Repository,
            nameof(SaveDataAsync),
            async () =>
            {
                var rs = await da.CreateMultiAsync(elems);
                Validation.vResultData(rs);
                return rs.Data;
            }
        );
    }
}
```

**Concrete Class: composition + configuration, no boilerplate**

```csharp
public class TypeRepository : ApplicationRepository, TypeRepositoryInterface
{
    public TypeRepository(
      ExecutorInterface executor, DatabaseAdapterInterface da) : base(executor, da)
    {
        table= "tbl_name";
    }
}
```

**Concrete Class: composition + configuration, no boilerplate**
```csharp
public interface TypeRepositoryInterface : ApplicationRepositoryInterface
{
    // no extra methods — marker only
}
```
## **Benefit**

- **Significantly reduces boilerplate** when multiple classes share similar workflows

- Concrete classes **override only** what matters

- **Supports DI cleanly** even with abstract base classes

- **Encourages consistency** across layers without forcing inheritance everywhere

---
## **Note**
**This is a high risk high reward pattern, **don't abuse it blindly***  
**Some patterns in Chimera can create epic combo if combined with each other, this one is one of them*

## **Debate**
***Q. Bros! this is not even interface maker, wtf with the template method? design pattern invertion?***  
*A. Bros! I'm sorry, I **misused** it. My bad. (But it works tho...)*

***Q. You put table name **INSIDE** repository??***  
*A. Ok, so should I put the *entire SQL query* there instead?*  
*(*Just kidding, you can use reflection.)*