# **Template Method × Composition × Marker Interface**
*If this chapter ends up confusing you, the shortcut is right* [*here*](https://github.com/0x76agabond/chimera-architecture/blob/main/Pattern/10.%20vision.md)

---

I once met a poor guy working as a solo dev, maintaining an old codebase.  
His daily routine was simple, come in, drink some coffee, and fix whatever bug appeared that day.

Then one day the project he maintained suddenly became mission critical.  
A dozen new features arrived, deadlines piled up, and the company still believed they did not need to hire another developer.  

And my guy...  
**Somehow still tried to apply Clean Architecture and SOLID to everything he touched, no matter how much overtime it cost him.**  
*That is real bravery.*  

He reminded me of the 300 Spartans  
Fighting even when they knew they could not win.

To help that Spartan, I finally designed this.  
Something that gives him a little space to breathe.  
After all, every Spartan deserves a spear! 

## **Ideas**

This pattern is used across the `Chimera Architecture` to keep each layer predictable, easy to extend, and free from boilerplate.  
It combines three simple ideas:  

- **Template Method** → shared flow, overridable details  
- **Composition** → behavior is injected, not inherited  
- **Marker Interface** → type-safe contracts without extra logic  ( **`DI container` forced me to use it* )  

In the end, with a bit of duct tape and some questionable courage, we created a pattern that has the full power of inheritance, stays fully testable, and still maintains a healthy relationship with DI.

## **Misuse the Pattern**

#### **Template Method**
- The Template Method is intentionally inverted: the **base class** contains the shared logic used by ~80% of subclasses, while **child classes orchestrate the final behavior**.  
- It may include small logic steps (e.g., check → action → after-check), but it **must never manage long business flows**.

#### **Composition**
- Composition injects behavior dynamically, ensuring the template stays lightweight and flexible.  
- Any behavior that affects <20% of use-cases should be added through **pure composition**, not the template.

#### **Marker Interface**
- A marker interface is normally empty, but in Chimera it **inherits the base interface** to enforce type contracts.  
- It may optionally expose **extra functions** if a specific domain needs extension without breaking the template.

## **Rules**

- Template Method defines only the **shared workflow skeleton** — never the business rules.
- Template Methods are **append-only**: extend the flow, do not rewrite existing steps.
- If a change affects **30%+** of child classes → create a new template instead of mutating the old one.
- If a behavior applies to **<20%** of cases → prefer pure Composition × Interface instead of inheritance.
- Child classes may override steps, but must not turn the Template Method into a long-form orchestrator.


## **Real Rules**

1. **Keep functions clean**  
   Each step does exactly one thing. Add new steps when needed, avoid modifying existing logic.

2. **The percentages decision**  
   Template Method handles the 80% common workflow; use overrides or composition for the remaining 20%.  
   Treat the percentages as an anchor, not a strict rule — always ask: **“Is this worth a new template?”**

3. **Flexible skeleton**  
   The template defines a stable workflow outline; behavior is extended through composition or overrides, not long-form orchestration.

## **Example**

**Abstract Template: shared workflow**

```csharp
public abstract class ApplicationRepository : ApplicationRepositoryInterface
{
    protected readonly ExecutorInterface executor;
    protected readonly DatabaseAdapterInterface da;

    public ApplicationRepository(ExecutorInterface executor, DatabaseAdapterInterface da)
    {
        this.executor = executor;
        this.da = da;
    }

    // Template Method: common workflow for all repositories
    // Override only when your domain needs it.
    public virtual async Task<Result<int>> SaveDataAsync<T>(List<T> elems) where T : class
    {
        return await executor.RunAsync(
            LogLayer.Repository,
            nameof(SaveDataAsync),
            async () =>
            {
                var rs = await da.CreateMultiAsync(elems);
                Validation.vResultData(rs);
                return rs.Data;
            }
        );
    }
}
```

**Concrete Class: composition + configuration, no boilerplate**

```csharp
public class TypeRepository : ApplicationRepository, TypeRepositoryInterface
{
    public TypeRepository(ExecutorInterface executor, DatabaseAdapterInterface da) : base(executor,da) 
    {
        // yes, no body here!        
    }
}
```

**Concrete Class: composition + configuration, no boilerplate**
```csharp
public interface TypeRepositoryInterface : ApplicationRepositoryInterface
{
    // no body here either!
}
```
## **Benefit**

- **Significantly reduces boilerplate** when multiple classes share similar workflows  
*With CRUD heavy project, this pattern can eliminate 70-80% `Repository` code*

- Concrete classes **override only** what matters

- **Supports DI cleanly** even with abstract base classes

- **Encourages consistency** across layers without forcing inheritance everywhere

## **Note**
**This is a high risk high reward pattern, **don't abuse it blindly***  
**If you stick with the rules, everything will be fine. But if you ever modify a template, your entire project will require a full regression test, no exceptions.*

**Some patterns in Chimera can create epic combo if combined with each other, this one is one of them*

## **Debate**
***Q. Bros! this is not even interface maker, wtf with the template method? design pattern invertion?***  
*A. Bros! I'm sorry, I **misused** it. My bad. (But it works tho...)*

***Q. Then how do you even know which table to save??***  
*A. I use ancient incantations.*  
**Just kidding, you can use reflection.*

***Q. This is just inheritance and polymorphism.***  
*A. Yes, every GoF pattern is basically the four pillars of OOP in disguise.*   
**Nice catch!*
